<!-- /* cSpell:disable */ -->
<div id="calendar-widget" class="calendar-widget">
    <h3 class="calendar-title">üìÖ Kommende Aktiviteter</h3>
    <div id="calendar-events" class="calendar-events">
        <p class="calendar-loading">Indl√¶ser aktiviteter...</p>
    </div>
</div>

<style>
.calendar-widget {
    border: 1px solid var(--border-color, #ddd);
    padding: 20px;
    border-radius: 8px;
    background: var(--bg-color, #fff);
    color: var(--text-color, #333);
    margin: 1rem 0;
}

.calendar-title {
    color: var(--heading-color, #333);
    margin-top: 0;
    margin-bottom: 1rem;
}

.calendar-loading {
    color: var(--muted-color, #666);
    font-style: italic;
}

.calendar-event {
    margin-bottom: 15px;
    padding: 15px;
    background: var(--card-bg, #f9f9f9);
    border-radius: 8px;
    border-left: 4px solid var(--accent-color, #4CAF50);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.calendar-event-title {
    font-weight: bold;
    color: var(--accent-color, #4CAF50);
    font-size: 1.1em;
    margin-bottom: 8px;
}

.calendar-event-meta {
    font-size: 0.9em;
    color: var(--muted-color, #666);
    margin-bottom: 8px;
}

.calendar-event-description {
    font-size: 0.9em;
    color: var(--text-color, #333);
    line-height: 1.4;
}

.calendar-error {
    color: var(--error-color, #ff6b6b);
}

.calendar-empty {
    color: var(--muted-color, #666);
}

/* Dark mode support - these will apply when body has "list dark" class */
body.list.dark .calendar-widget {
    border-color: #444;
    background: #2d2d2d;
    color: #e0e0e0;
}

body.list.dark .calendar-title {
    color: #ffffff;
}

body.list.dark .calendar-loading,
body.list.dark .calendar-empty {
    color: #b0b0b0;
}

body.list.dark .calendar-event {
    background: #3a3a3a;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

body.list.dark .calendar-event-meta {
    color: #b0b0b0;
}

body.list.dark .calendar-event-description {
    color: #d0d0d0;
}
</style>

<script>
async function loadCalendarEvents() {
    try {
        // Use a CORS proxy to fetch the iCal data
        const response = await fetch('https://api.allorigins.win/get?url=' + encodeURIComponent('https://api.minforening.dk/api/v3/clubs/5219/ical'));
        const data = await response.json();
        let icalData = data.contents;
        
        // Check if the data is base64 encoded
        if (icalData.startsWith('data:text/calendar') && icalData.includes('base64,')) {
            // Extract the base64 part and decode it
            const base64Data = icalData.split('base64,')[1];
            icalData = atob(base64Data);
            console.log('Decoded base64 iCal data');
        }
        
        // Parse iCal data (basic parsing)
        const events = parseICalEvents(icalData);
        console.log('Parsed events:', events);
        displayEvents(events);
    } catch (error) {
        document.getElementById('calendar-events').innerHTML = '<p class="calendar-error">‚ùå Kunne ikke indl√¶se aktiviteter</p>';
        console.error('Calendar load error:', error);
    }
}

// Function to decode iCal text properly
function decodeICalText(text) {
    if (!text) return text;
    
    // First try to decode as URI component if it looks encoded
    let decoded = text;
    try {
        if (text.includes('%')) {
            decoded = decodeURIComponent(text);
        }
    } catch (e) {
        // If URI decoding fails, continue with original text
        decoded = text;
    }
    
    // Fix double UTF-8 encoding issues by converting back to proper encoding
    try {
        // Encode as Latin-1 then decode as UTF-8 to fix double encoding
        const latin1Bytes = [];
        for (let i = 0; i < decoded.length; i++) {
            latin1Bytes.push(decoded.charCodeAt(i) & 0xFF);
        }
        const uint8Array = new Uint8Array(latin1Bytes);
        decoded = new TextDecoder('utf-8').decode(uint8Array);
    } catch (e) {
        // If encoding conversion fails, fall back to manual replacements
        decoded = decoded
            // Fix Danish characters that are double-encoded
            .replace(/√É¬•/g, '√•')
            .replace(/√É¬¶/g, '√¶')
            .replace(/√É¬∏/g, '√∏')
            .replace(/√É‚Ä†/g, '√Ü')
            .replace(/√ÉÀú/g, '√ò')
            .replace(/√É‚Ä¶/g, '√Ö')
            // Additional common encoding issues
            .replace(/√É¬©/g, '√©')
            .replace(/√É¬§/g, '√§')
            .replace(/√É¬∂/g, '√∂');
    }
    
    // Decode common iCal escape sequences
    decoded = decoded
        .replace(/\\n/g, '\n')  // New lines
        .replace(/\\,/g, ',')   // Commas
        .replace(/\\;/g, ';')   // Semicolons
        .replace(/\\\\/g, '\\'); // Backslashes
    
    // Fix specific broken emoji sequences we see in the data
    decoded = decoded
        .replace(/√¢¬µ√Ø¬∏√∞/g, '‚õµÔ∏èüìç')  // Sailboat + pin
        .replace(/√¢¬µ√Ø¬∏/g, '‚õµÔ∏è')     // Sailboat with variant selector
        .replace(/√¢¬µ/g, '‚õµ')       // Sailboat
        .replace(/√∞ √Ø¬∏/g, 'üõ†Ô∏è')     // Tools
        .replace(/√∞/g, 'üìç')       // Pin location
        .replace(/√¢/g, '‚öì')       // Anchor
        // Clean up any remaining broken characters
        .replace(/[√¢√Ø¬∏]/g, '')    // Remove broken combining chars
        // Clean up double spaces
        .replace(/\s+/g, ' ')
        .trim();
    
    return decoded;
}

// Function to check if text already contains common icons
function hasIcon(text, iconType) {
    if (!text) return false;
    
    const iconMap = {
        'location': ['üìç', 'üó∫Ô∏è', '√∞'],
        'date': ['üìÖ', 'üóìÔ∏è'],
        'time': ['üïê', '‚è∞']
    };
    
    return iconMap[iconType]?.some(icon => text.includes(icon)) || false;
}

function parseICalEvents(icalData) {
    const events = [];
    const lines = icalData.split('\n');
    let currentEvent = {};
    
    for (let line of lines) {
        line = line.trim();
        if (line === 'BEGIN:VEVENT') {
            currentEvent = {};
        } else if (line === 'END:VEVENT') {
            if (currentEvent.summary && currentEvent.dtstart) {
                // Decode all text fields
                currentEvent.summary = decodeICalText(currentEvent.summary);
                currentEvent.description = decodeICalText(currentEvent.description);
                currentEvent.location = decodeICalText(currentEvent.location);
                events.push(currentEvent);
            }
        } else if (line.startsWith('SUMMARY:')) {
            currentEvent.summary = line.substring(8);
        } else if (line.startsWith('DTSTART:')) {
            const dateStr = line.substring(8);
            currentEvent.dtstart = parseICalDate(dateStr);
        } else if (line.startsWith('DTEND:')) {
            const dateStr = line.substring(6);
            currentEvent.dtend = parseICalDate(dateStr);
        } else if (line.startsWith('DESCRIPTION:')) {
            currentEvent.description = line.substring(12);
            // Debug: log raw description to see encoding
            console.log('Raw description:', line.substring(12));
        } else if (line.startsWith('LOCATION:')) {
            currentEvent.location = line.substring(9);
            // Debug: log raw location to see encoding
            console.log('Raw location:', line.substring(9));
        }
    }
    
    // Sort by date and take next 5 events
    return events
        .filter(event => event.dtstart > new Date())
        .sort((a, b) => a.dtstart - b.dtstart)
        .slice(0, 5);
}

function parseICalDate(dateStr) {
    // Handle YYYYMMDDTHHMMSSZ format
    if (dateStr.length >= 8) {
        const year = dateStr.substring(0, 4);
        const month = dateStr.substring(4, 6);
        const day = dateStr.substring(6, 8);
        let time = '';
        if (dateStr.includes('T') && dateStr.length >= 15) {
            const hour = dateStr.substring(9, 11);
            const minute = dateStr.substring(11, 13);
            time = ` ${hour}:${minute}`;
        }
        return new Date(`${year}-${month}-${day}${time}`);
    }
    return new Date(dateStr);
}

function displayEvents(events) {
    const container = document.getElementById('calendar-events');
    
    if (events.length === 0) {
        container.innerHTML = '<p class="calendar-empty">üì≠ Ingen kommende aktiviteter findes i √∏jeblikket</p>';
        return;
    }
    
    const eventsHtml = events.map(event => {
        const date = event.dtstart.toLocaleDateString('da-DK', {
            weekday: 'short',
            day: 'numeric',
            month: 'short'
        });
        const time = event.dtstart.toLocaleTimeString('da-DK', {
            hour: '2-digit',
            minute: '2-digit'
        });
        
        // Clean up description - remove extra formatting
        let description = event.description;
        if (description) {
            description = description
                .replace(/\n\n/g, '<br>')
                .replace(/\n/g, ' ')
                .substring(0, 150); // Limit length
            if (event.description.length > 150) {
                description += '...';
            }
        }
        
        // Check if location already has an icon, if not add one
        const locationText = event.location 
            ? (hasIcon(event.location, 'location') 
                ? event.location 
                : `üìç ${event.location}`)
            : '';
        
        return `
            <div class="calendar-event">
                <div class="calendar-event-title">${event.summary}</div>
                <div class="calendar-event-meta">
                    üìÖ ${date} kl. ${time}
                    ${locationText ? `<br>${locationText}` : ''}
                </div>
                ${description ? `<div class="calendar-event-description">${description}</div>` : ''}
            </div>
        `;
    }).join('');
    
    container.innerHTML = eventsHtml;
}

// Load events when page loads
document.addEventListener('DOMContentLoaded', loadCalendarEvents);
</script>